<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<HTML><HEAD><TITLE>Ethereal协议分析系统介绍_在0与1中寻找快乐</TITLE>
<STYLE type=text/css>
.error{color:#FF0000;font-size:12px}
</STYLE>
</HEAD>

<BODY>

<CENTER>

<DIV id=main style="WIDTH: 996px" align=left>

<DIV class=stage>

<DIV class=stagepad>

<DIV style="WIDTH: 100%">

<DIV class=modbox id=m_blog><!--StartFragment--><DIV class=tit>Ethereal协议分析系统介绍</DIV>
<DIV class=date>2009-03-09 11:11</DIV>
<TABLE style="TABLE-LAYOUT: fixed">
<TBODY>
<TR>
<TD>
<DIV class=cnt id=blog_text>
<P>Ethereal是一个开放源码的网络分析系统，也是是目前最好的开放源码的网络协议分析器，支持Linux和windows平台。Ethereal起初由Gerald 
Combs开发，随后由一个松散的Etheral团队组织进行维护开发。它目前所提供的强大的协议分析功能完全可以媲美商业的网络分析系统，自从1998年发布最早的0.2版本至今，大量的志愿者为Ethereal添加新的协议解析器，如今Ethereal已经支持五百多种协议解析。很难想象如此多的人开发的代码可以很好的融入系统中；并且在系统中加入一个新的协议解析器很简单，一个不了解系统的结构的新手也可以根据留出的接口进行自己的协议开发。这都归功于Ehereal良好的设计结构。事实上由于网络上各种协议种类繁多，各种新的协议层出不穷。一个好的协议分析器必需有很好的可扩展性和结构。这样才能适应网络发展的需要不断加入新的协议解析器。</P>
<P>1 Ethereal的捕包平台</P>
<P>　　网络分析系统首先依赖于一套捕捉网络数据包的函数库。这套函数库工作在在网络分析系统模块的最底层。作用是从网卡取得数据包或者根据过滤规则取出数据包的子集，再转交给上层分析模块。从协议上说，这套函数库将一个数据包从链路层接收，至少将其还原至传输层以上，以供上层分析。</P>
<P>在Linux系统中， 1992年Lawrence Berkeley Lab的Steven McCanne和Van 
Jacobson提出了包过滤器的一种的实现，BPF（BSD Packet 
Filter）。Libpcap是一个基于BPF的开放源码的捕包函数库。现有的大部分Linux捕包系统都是基于这套函数库或者是在它基础上做一些针对性的改进</P>
<P>　　在window系统中，意大利人Fulvio Risso和Loris 
Degioanni提出并实现了Winpcap函数库，作者称之为NPF。由于NPF的主要思想就是来源于BPF，它的设计目标就是为windows</P>
<P>　　系统提供一个功能强大的开发式数据包捕获平台，希望在Linux系统中的网络分析工具经过简单编译以后也可以移植到windows中，因此这两种捕包架构是非常现实的。就实现来说提供的函数调用接口也是一致的。</P>
<P>　　Ethereal网络分析系统也需要一个底层的抓包平台，在Linux中是采用Libpcap函数库抓包，在windows系统中采用winpcap函数库抓包</P>
<P>2层次化的数据包协议分析方法</P>
<P>　　取得捕包函数捕回的数据包后就需要进行协议分析和协议还原工作了。由于OSI的7层协议模型，协议数据是从上到下封装后发送的。对于协议分析需要从下至上进行。首先对网络层的协议识别后进行组包还原然后脱去网络层协议头。将里面的数据交给传输层分析，这样一直进行下去直到应用层</P>
<P>Ip</P>
<P>|</P>
<P>Tcp udp</P>
<P>|</P>
<P>HTTP TFTP</P>
<P>　　由于网络协议种类很多，就Ethereal所识别的500多种协议来说，为了使协议和协议间层次关系明显。从而对数据流里的各个层次的协议能够逐层处理。Ethereal系统采用了协议树的方式。上图就是一个简单的协议树。如果协议A的所有数据都是封装在协议B里的，那么这个协议A就是协议B是另外一个协议的儿子节点。我们将最低层的无结构数据流作为根接点。那么具有相同父节点的协议成为兄弟节点。那么这些拥有同样父协议兄弟节点协议如何互相区分了？Ethereal系统采用协议的特征字来识别。每个协议会注册自己的特征字。这些特征字给自己的子节点协议提供可以互相区分开来的标识。比如tcp协议的port字段注册后。 
Tcp.port=21就可以认为是ftp协议， 特征字可以是协议规范定义的任何一个字段。比如ip协议就可以定义proto字段为一个特征字。</P>
<P>　　在Ethereal中注册一个协议解析器首先要指出它的父协议是什么。另外还要指出自己区别于父节点下的兄弟接点协议的特征。比如ftp协议。在Ethereal中他的父接点是tcp协议，它的特征就是tcp协议的port字段为21。</P>
<P>　　这样当一个端口为21的tcp数据流来到时。首先由tcp协议注册的解析模块处理，处理完之后通过查找协议树找到自己协议下面的子协议，判断应该由那个子协议来执行，找到正确的子协议后，就转交给ftp注册的解析模块处理。这样由根节点开始一层层解析下去。</P>
<P>　　由于采用了协议树加特征字的设计，这个系统在协议解析上由了很强的扩展性，增加一个协议解析器只需要将解析函数挂到协议树的相应节点上即可。</P>
<P>3 基于插件技术的协议分析器</P>
<P>　　所谓插件技术，就是在程序的设计开发过程中，把整个应用程序分成宿主程序和插件两个部分，宿主程序与插件能够相互通信，并且，在宿主程序不变的情况下，可以通过增减插件或修改插件来调整应用程序的功能。运用插件技术可以开发出伸缩性良好、便于维护的应用程序。它著名的应用实例有：媒体播放器winamp、微软的网络浏览器ie等。</P>
<P>　　由于现在网络协议种类繁多，为了可以随时增加新的协议分析器，一般的协议分析器都采用插件技术，这样如果需要对一个新的协议分析只需要开发编写这个协议分析器并调用注册函数在系统注册就可以使用了。通过增加插件使程序有很强的可扩展性，各个功能模块内聚。</P>
<P>　　在协议分析器中新增加一个协议插件一般需要插件安装或者注册，插件初始化，插件处理3个步骤，下面以Ethereal为例进行分析如何利用插件技术新增加一个协议分析模块。</P>
<P>　　Ethereal由于采用插件技术，一个新加入开发的程序员开发一种新的协议分析模块的时候不需要了解所有的代码，他只需要写好这个协议模块的函数后，写一个格式为proto_reg_handoff_XXX的函数，在函数内调用注册函数告诉系统在什么时候需要调用这个协议模块。比如</P>
<P>　　你事先写好了一个名为dissect_myprot的协议解析模块，它是用来解析tcp协议端口为250的数据。可以利用这些语句来将这个解析器注册到系统中</P>
<P>proto_reg_handoff_myprot(void)</P>
<P>{</P>
<P>dissector_handle_t myprot_handle;</P>
<P>myprot_handle = create_dissector_handle(dissect_myprot,</P>
<P>proto_myprot);</P>
<P>dissector_add("tcp.port", 250, myprot_handle);</P>
<P>}</P>
<P>这段代码告诉系统当tcp协议数据流端口为250的时候要调用dissect_myprot这个函数模块。</P>
<P>　　在Ethereal中有一个角本专门来发现开发者定义的类式proto_reg_handoff_xxx这样的注册函数名，然后自动生成调用这些注册函数的代码。这样开发者不需要知道自己的注册函数如何被调用的。这样一个新的协议分析模块就加入到系统中了。</P>
<P>　　由于采用了插件方式，Ethereal良好的结构设计让开发者只需要关系自己开发的协议模块，不需要关心整个系统结构，需要将模块整合进系统只需要写一个注册函数即可，连初始化时调用这个注册函数都由脚本自动完成了。正是因为有很好的体系结构，这个系统才能够开发出如此多的协议解析器</P>
<P>　　尽管Ethereal是目前最好的开放源码的网络分析系统，但Ethereal仍然有一些可以改进的地方，一个优秀的网络分析器，尽可能的正确分析出数据协议和高效的处理数据是两个重要的指标。在协议识别方面Ethereal大多采用端口识别，有少量协议采用内容识别。这就让一些非标准端口的协议数据没有正确解析出来。比如ftp协议如果不是21端口的话，Ethereal就无法识别出来，只能作为tcp数据处理。另外对于内容识别式。Ethereal是将所以内容识别的函数组成一张入口表。每次协议数据需要内容识别时，按字母顺序逐个调用表里的每个识别函数。比如对于识别yahoo 
massanger协议。主要是看数据前几个字节是不是’ymsg’.由于协议名为y开头。所以当识别出协议时已经把所有内容识别函数调用了一遍。这些都是由于Ethereal没有实现tcp协议栈，无法做到流级别的识别。导致在协议识别方面有点缺陷。</P>
<P>　　</P></DIV></TD></TR></TBODY></TABLE><!--EndFragment--></DIV>
</DIV>
</DIV>
</DIV>
</DIV>
</CENTER>
</BODY>
</HTML>