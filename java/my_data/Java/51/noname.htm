<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">

<HTML xmlns="http://www.w3.org/1999/xhtml" sizcache="1" 
sizset="32">
<HEAD>
<title>Lucene2.9.1使用小结</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<<LINK media=all href="Hover_1.css" 
type=text/css rel=stylesheet>
<LINK media=all 
href="csdn_favbykimi.css" type=text/css 
rel=stylesheet>
<LINK href="1.ico" 
rel="Shortcut Icon">
<LINK title=RSS 
href="qjyong" type=application/rss+xml 
rel=alternate>
<LINK media=screen 
href="SyntaxHighlighter.css" 
type=text/css rel=stylesheet>
<STYLE type=text/css>
.dp-j .annotation {
	COLOR: #646464
}
.dp-j .number {
	COLOR: #c00000
}
</STYLE>
<STYLE type=text/css>
.dp-j .annotation {
	COLOR: #646464
}
.dp-j .number {
	COLOR: #c00000
}
</STYLE>
<STYLE type=text/css>
.dp-j .annotation {
	COLOR: #646464
}
.dp-j .number {
	COLOR: #c00000
}
</STYLE>
<STYLE type=text/css>
.dp-j .annotation {
	COLOR: #646464
}
.dp-j .number {
	COLOR: #c00000
}
</STYLE>
<STYLE type=text/css>
.dp-j .annotation {
	COLOR: #646464
}
.dp-j .number {
	COLOR: #c00000
}
</STYLE>
<STYLE type=text/css>
.dp-j .annotation {
	COLOR: #646464
}
.dp-j .number {
	COLOR: #c00000
}
</STYLE>
</HEAD>

<BODY id="defaultuser" sizcache="1" sizset="32">
<DIV id="csdnblog_allwrap" sizcache="1" sizset="32">
  <DIV id="csdnblog_midwrap" sizcache="1" sizset="32">
    <DIV id=csdnblog_content><!--StartFragment-->
      <DIV class=gutter>
        <DIV class=default_contents>
          <DIV class=user_article> 
            
            <H1 class=title_txt><IMG border=0 alt=原创 
src="authorship.gif" width=15 height=16>&nbsp; 
              Lucene2.9.1使用小结 <CITE class=fav_csdnstylebykimi><A title=收藏到我的网摘中，并分享给我的朋友 
class=fav_csdnstylebykimi 
href="javascript:d=document;t=d.selection%3F(d.selection.type!='None'?d.selection.createRange().text:''):(d.getSelection?d.getSelection():'');void(saveit=window.open('http://wz.csdn.net/storeit.aspx?t='+escape(d.title)+'&amp;u='+escape(d.location.href)+'&amp;c='+escape(t),'saveit','scrollbars=no,width=590,height=300,left=75,top=20,status=no,resizable=yes'));saveit.focus();">收藏</A> </CITE> 
              
              <SPAN onmouseover="change_alt1('alt02','block')" 
style="HEIGHT: 0px; WIDTH: 0px; POSITION: absolute" 
onmouseout="change_alt1('alt02','none')"><IMG 
style="POSITION: absolute; LEFT: 50px; TOP: -40px" 
src="tuijian.gif" align=absMiddle>
              <DIV class=div>
                <P id=alt02 onmouseover="change_alt1('alt02','block')" 
onmouseout="change_alt1('alt02','none')">此文于2009-11-25被推荐到CSDN首页<BR>
                  <A 
href="http://blog.csdn.net/blogdevteam/archive/2009/08/25/4481848.aspx" 
target=_blank>如何被推荐？</A></P></DIV>
              </SPAN></H1>
            <DIV class=blogstory> 
              
              
              <P>【注意：本文版权归++yong所有，转载请注明。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 】</P>
              <P>【++yong的博客地址：<A 
href="http://blog.csdn.net/qjyong">http://blog.csdn.net/qjyong</A>】</P>
              <P>开源全文搜索工具包Lucene2.9.1的使用。</P>
              <P>1. 搭建Lucene的开发环境：在classpath中添加lucene-core-2.9.1.jar包<BR>
                &nbsp;&nbsp; <BR>
                2. 全文搜索的两个工作: 
                建立索引文件,搜索索引.<BR>
                &nbsp;&nbsp; <BR>
                3. Lucene的索引文件逻辑结构<BR>
                &nbsp; 1) 
                索引(Index)由若干块(片段)(Segment)组成<BR>
                &nbsp; ★2) 块由若干文档(Document)组成: 
                一个文件映射成一个文档。数据库表中的一条记录映射成一个文档。<BR>
                &nbsp; ★3) 
                文档由若干域(Field)组成：文件的属性(文件路径，文件的内容)映射成一个域。记录的某个字段映射成一个域。<BR>
                &nbsp; ☆4) 
                域由若干词(关键字)(Term)组成：文件的属性的内容中某个字符串映射成一个词。<BR>
                &nbsp; <BR>
                4. Lucene包结构<BR>
                &nbsp; 1) 
                analysis模块：负责词法分析及语言处理而形成Term(词)。提供了一些内置的分析器：最常用的是StandardAnalyzer<BR>
                &nbsp; 2) 
                index模块：负责索引的读写。 
                对索引文件的segment进行写、合并、优化的IndexWriter类。对索引进行读取和删除操作的IndexReader类。<BR>
                &nbsp; 3) 
                store模块：负责索引的存储。提供索引的各种存储类：FSDirectory，RAMDirectory等。<BR>
                &nbsp; 4) 
                document模块：索引文件内部的基础存储结构封装。如：Document类和Field类等。<BR>
                &nbsp; 5) 
                search模块：负责对索引的搜索。提供了索引搜索器IndexSearcher类和各种Query类，如TermQuery、BooleanQuery等。<BR>
                &nbsp; 
                6) queryParser模块：负责查询语句的语法分析。提供了解析查询语句的QueryParser类<BR>
                &nbsp; 7) 
                util模块：包含一些公共工具类。</P>
              <P>5. 创建索引<BR>
                &nbsp; 1) IndexWriter：索引写出器<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; a) 构造方法：<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                IndexWriter(Directory d, Analyzer a, IndexWriter.MaxFieldLength mfl) <BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果索引不存在，就会被创建。如果索引存在,就追加. <BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexWriter(Directory&nbsp;d, 
                Analyzer&nbsp;a, boolean&nbsp;create, IndexWriter.MaxFieldLength&nbsp;mfl) <BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                create为true时，原索引文件不存在就创建，存在就覆盖。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                create为false时，原索引文件不存在就报错，存在就追加。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; b) 常用方法:<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void 
                addDocument(Document doc);&nbsp; //把指定文档添加到索引写出器中<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void iw.close();&nbsp; 
                //关闭索引写出器,此时才把索引写到目标存储地<BR>
                &nbsp; <BR>
                &nbsp; 2) Directory: 索引存放地。 <BR>
                &nbsp;&nbsp;&nbsp;&nbsp; a) 
                文件系统:FSDirectory:&nbsp; FSDirectory.open(File file);<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; b) 内存RAMDirectory:&nbsp; new 
                RAMDirectory();<BR>
                &nbsp; <BR>
                &nbsp; 3) Analyzer: 分词器。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; a) StandardAnalyzer:&nbsp; 
                标准分词器。对英文采用空白, 标点符号进行分词。对中文采用单字分词。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; b) SmartChineseAnalyzer:&nbsp; 
                智能中文分词器。(LUCENE_HOME/contrib/analyzers/smartcn/lucene-smartcn-2.9.1.jar)<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; 
                C) 第三方的中文分词器：如PaodingAnalyzer、IKAnalyzer<BR>
                &nbsp; <BR>
                &nbsp; 4) 
                IndexWriter.MaxFieldLength: 指定域值的最大长度。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; a) UNLIMITED 无限制的。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; b) 
                LIMITED 有限制的。值为10000<BR>
                &nbsp; <BR>
                &nbsp; 5) Document: 索引的组成单元. 一组Field的集合.<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; a) 
                构造方法: Document();<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; b) 常用方法: void add(Field f);&nbsp; //添加指定域到这个文档中<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; <BR>
                &nbsp; 6) Field: 域,代表文档的某个索引域.<BR>
                &nbsp;&nbsp;&nbsp;&nbsp; a) 构造方法: Field(String name, String value, 
                Field.Store.YES, Field.Index.ANALYZED)<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name: 域的名称, 只能是字符串.<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                value: 域的值, 只能是字符串. <BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field.Store: 指定Field的值是否存储或怎样存储. NO(不存储), 
                YES(存储),COMPRESS(压缩后存储)<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Field.Index: 指定Field是否被索引或怎么被索引. NO(不索引), 
                ANALYZED(分词后索引), NOT_ANALYZED(不分词直接索引) <BR>
                &nbsp; 7) 示例代码:<BR>
              </P>
              
              <DIV class=dp-highlighter>
                <DIV class=bar></DIV>
                <OL class=dp-j>
                  <LI class=alt><SPAN><SPAN class=comment>//src要创建索引的文件，destDir索引存放的目录 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN class=keyword>public</SPAN><SPAN>&nbsp;</SPAN><SPAN 
class=keyword>static</SPAN><SPAN>&nbsp;</SPAN><SPAN 
class=keyword>void</SPAN><SPAN>&nbsp;createIndex(File&nbsp;src,&nbsp;File&nbsp;destDir){ 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;Analyzer&nbsp;analyzer&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;StandardAnalyzer(Version.LUCENE_CURRENT);&nbsp;</SPAN><SPAN 
class=comment>//创建一个语法分析器 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;IndexWriter&nbsp;iwriter&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;Directory&nbsp;directory&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;</SPAN><SPAN class=keyword>try</SPAN><SPAN>&nbsp;{ 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;directory&nbsp;=&nbsp;FSDirectory.open(destDir);&nbsp;</SPAN><SPAN 
class=comment>//把索引文件存储到磁盘目录 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=comment>//创建一个IndexWriter(存放索引文件的目录,分析器,Field的最大长度) </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;iwriter&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;IndexWriter(directory,&nbsp;analyzer,</SPAN><SPAN 
class=keyword>true</SPAN><SPAN>,&nbsp;IndexWriter.MaxFieldLength.UNLIMITED); 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=comment>//iwriter.setUseCompoundFile(true);//使用复合文件 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;Document&nbsp;doc&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Document();&nbsp;</SPAN><SPAN 
class=comment>//创建一个Document对象 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN class=comment>//把文件路径作为"path"域：不分词,索引,保存 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;doc.add(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Field(</SPAN><SPAN 
class=string>"path"</SPAN><SPAN>,&nbsp;src.getCanonicalPath(),&nbsp;Field.Store.YES,&nbsp;Field.Index.NOT_ANALYZED)); 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;StringBuilder&nbsp;sb&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;StringBuilder(); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;BufferedReader&nbsp;br&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;BufferedReader(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;FileReader(src)); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=keyword>for</SPAN><SPAN>(String&nbsp;str&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>;&nbsp;(str&nbsp;=&nbsp;br.readLine())!=</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>;){ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;sb.append(str).append(System.getProperty(</SPAN><SPAN 
class=string>"line.separator"</SPAN><SPAN>));&nbsp; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN class=comment>//文件内容作为"content"域：分词,索引,保存 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;doc.add(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Field(</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>,&nbsp;sb.toString(),&nbsp;Field.Store.YES,&nbsp;Field.Index.ANALYZED));&nbsp; 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;iwriter.addDocument(doc);&nbsp;</SPAN><SPAN 
class=comment>//把Document存放到IndexWriter中 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;iwriter.optimize();&nbsp;&nbsp;</SPAN><SPAN 
class=comment>//对索引进行优化&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(IOException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;}&nbsp;</SPAN><SPAN class=keyword>finally</SPAN><SPAN>&nbsp;{&nbsp; 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=keyword>if</SPAN><SPAN>&nbsp;(iwriter&nbsp;!=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=keyword>try</SPAN><SPAN>&nbsp;{ 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;iwriter.close();&nbsp;</SPAN><SPAN 
class=comment>//关闭IndexWriter时,才把内存中的数据写到文件&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(IOException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;}&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=keyword>if</SPAN><SPAN>&nbsp;(directory&nbsp;!=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=keyword>try</SPAN><SPAN>&nbsp;{ 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;directory.close();&nbsp;</SPAN><SPAN class=comment>//关闭索引存放目录 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(IOException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</SPAN></LI>
                </OL>
              </DIV><TEXTAREA class=java:nocontrols style="DISPLAY: none" rows=15 cols=78 name=code>//src要创建索引的文件，destDir索引存放的目录
public static void createIndex(File src, File destDir){
 Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_CURRENT); //创建一个语法分析器
 IndexWriter iwriter = null;
 Directory directory = null;
 try {
  directory = FSDirectory.open(destDir); //把索引文件存储到磁盘目录
  //创建一个IndexWriter(存放索引文件的目录,分析器,Field的最大长度)
  iwriter = new IndexWriter(directory, analyzer,true, IndexWriter.MaxFieldLength.UNLIMITED);
  //iwriter.setUseCompoundFile(true);//使用复合文件
     
  Document doc = new Document(); //创建一个Document对象
  //把文件路径作为"path"域：不分词,索引,保存
  doc.add(new Field("path", src.getCanonicalPath(), Field.Store.YES, Field.Index.NOT_ANALYZED));
  
  StringBuilder sb = new StringBuilder();
  BufferedReader br = new BufferedReader(new FileReader(src));
  for(String str = null; (str = br.readLine())!=null;){
   sb.append(str).append(System.getProperty("line.separator")); 
  }
  //文件内容作为"content"域：分词,索引,保存
  doc.add(new Field("contents", sb.toString(), Field.Store.YES, Field.Index.ANALYZED)); 
  
  iwriter.addDocument(doc); //把Document存放到IndexWriter中
  iwriter.optimize();  //对索引进行优化  
 } catch (IOException e) {
  e.printStackTrace();
 } finally { 
  if (iwriter != null) {
   try {
    iwriter.close(); //关闭IndexWriter时,才把内存中的数据写到文件 
   } catch (IOException e) {
    e.printStackTrace();
   } 
  }
  if (directory != null) {
   try {
    directory.close(); //关闭索引存放目录
   } catch (IOException e) {
    e.printStackTrace();
   }
  }
 }
}   
</TEXTAREA> 
<P></P>
              <P>6. 查询索引<BR>
                &nbsp; 1) IndexSearcher: 索引查询器<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) 构造器: 
                IndexSearcher(Directory&nbsp;path, boolean&nbsp;readOnly)<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 常用方法: <BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                TopDocs search(Query query, Filter filter, int n);&nbsp; 
                //执行查询。n指的是最多返回的Document的数量。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Document doc(int&nbsp;文件内部编号);&nbsp; 
                //根据文档的内部编号获取到该Document<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void close();&nbsp; //关闭查询器<BR>
                &nbsp; 2) Query: 
                查询对象。把用户输入的查询字符串封装成Lucene能够识别的Query对象。<BR>
                &nbsp; 3) Filter: 用来过虑搜索结果的对象。<BR>
                &nbsp; 4) 
                TopDocs: 代表查询结果集信息对象。它有两个属性：<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a) totalHits: 查询命中数。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b) 
                scoreDocs: 查询结果信息。它包含符合条件的Document的内部编号(doc)及评分(score)。<BR>
                &nbsp;&nbsp; 5) 示例代码:<BR>
              </P>
              
              <DIV class=dp-highlighter>
                <DIV class=bar></DIV>
                <OL class=dp-j>
                  <LI class=alt><SPAN><SPAN class=comment>//keyword要搜索的关键字。indexDir索引存放的目录 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN class=keyword>public</SPAN><SPAN>&nbsp;</SPAN><SPAN 
class=keyword>static</SPAN><SPAN>&nbsp;</SPAN><SPAN 
class=keyword>void</SPAN><SPAN>&nbsp;searcher(String&nbsp;keyword,&nbsp;File&nbsp;indexDir){ 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;IndexSearcher&nbsp;isearcher&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;Directory&nbsp;directory&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;</SPAN><SPAN class=keyword>try</SPAN><SPAN>{ 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;Analyzer&nbsp;analyzer&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;StandardAnalyzer(Version.LUCENE_CURRENT); 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;directory&nbsp;=&nbsp;FSDirectory.open(indexDir); &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN class=comment>//创建解析器 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;QueryParser&nbsp;parser&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;QueryParser(Version.LUCENE_CURRENT,&nbsp;</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>,&nbsp;analyzer); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;Query&nbsp;query&nbsp;=&nbsp;parser.parse(keyword);</SPAN><SPAN 
class=comment>//获取查询对象 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;Query&nbsp;query1&nbsp;=&nbsp;new&nbsp;TermQuery(new&nbsp;Term("contents",&nbsp;keyword)); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;Query&nbsp;query2&nbsp;=&nbsp;new&nbsp;TermQuery(new&nbsp;Term("contents",&nbsp;keyword2)); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;BooleanQuery&nbsp;query&nbsp;=&nbsp;new&nbsp;BooleanQuery(); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;query.add(query1,&nbsp;Occur.SHOULD); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;query.add(query2,&nbsp;Occur.SHOULD); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;QueryParser&nbsp;parser&nbsp;=&nbsp;new&nbsp;MultiFieldQueryParser(Version.LUCENE_CURRENT,&nbsp;new&nbsp;String[]{"path",&nbsp;"contents"},&nbsp;analyzer); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN 
class=comment>//&nbsp;&nbsp;Query&nbsp;query&nbsp;=&nbsp;parser.parse(keyword); </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;isearcher&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;IndexSearcher(directory,&nbsp;</SPAN><SPAN 
class=keyword>true</SPAN><SPAN>);&nbsp;&nbsp;</SPAN><SPAN class=comment>//创建索引搜索器 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;TopDocs&nbsp;ts&nbsp;=&nbsp;isearcher.search(query,&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=number>100</SPAN><SPAN>);&nbsp;&nbsp;</SPAN><SPAN class=comment>//执行搜索，获取查询结果集对象 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=keyword>int</SPAN><SPAN>&nbsp;totalHits&nbsp;=&nbsp;ts.totalHits;&nbsp;&nbsp;</SPAN><SPAN 
class=comment>//获取命中数 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;System.out.println(</SPAN><SPAN 
class=string>"命中数："</SPAN><SPAN>&nbsp;+&nbsp;totalHits); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;ScoreDoc[]&nbsp;hits&nbsp;=&nbsp;ts.scoreDocs;&nbsp;&nbsp;</SPAN><SPAN 
class=comment>//获取命中的文档信息对象 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN class=keyword>for</SPAN><SPAN>&nbsp;(</SPAN><SPAN 
class=keyword>int</SPAN><SPAN>&nbsp;i&nbsp;=&nbsp;</SPAN><SPAN 
class=number>0</SPAN><SPAN>;&nbsp;i&nbsp;&lt;&nbsp;hits.length;&nbsp;i++)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI 
><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Document&nbsp;hitDoc&nbsp;=&nbsp;isearcher.doc(hits[i].doc);&nbsp;</SPAN><SPAN 
class=comment>//根据命中的文档的内部编号获取该文档&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(hitDoc.getField(</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>).stringValue());&nbsp;</SPAN><SPAN 
class=comment>//输出该文档指定域的值 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(IOException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp; &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(ParseException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;}&nbsp;</SPAN><SPAN class=keyword>finally</SPAN><SPAN>&nbsp;{&nbsp;&nbsp;&nbsp; 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=keyword>if</SPAN><SPAN>&nbsp;(isearcher&nbsp;!=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>)&nbsp;{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=keyword>try</SPAN><SPAN>&nbsp;{&nbsp;&nbsp;&nbsp; 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;isearcher.close();&nbsp;</SPAN><SPAN class=comment>//关闭搜索器&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(IOException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;</SPAN><SPAN 
class=keyword>if</SPAN><SPAN>&nbsp;(directory&nbsp;!=&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>)&nbsp;{&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;</SPAN><SPAN class=keyword>try</SPAN><SPAN>&nbsp;{&nbsp;&nbsp;&nbsp; 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;directory.close();&nbsp;</SPAN><SPAN 
class=comment>//关闭索引存放目录&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;}&nbsp;</SPAN><SPAN 
class=keyword>catch</SPAN><SPAN>&nbsp;(IOException&nbsp;e)&nbsp;{ &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace(); &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>&nbsp;&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;} &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>}&nbsp;&nbsp;</SPAN></LI>
                </OL>
              </DIV><TEXTAREA class=java:nocontrols style="DISPLAY: none" rows=15 cols=79 name=code>//keyword要搜索的关键字。indexDir索引存放的目录
public static void searcher(String keyword, File indexDir){
 IndexSearcher isearcher = null;
 Directory directory = null;
 try{
  Analyzer analyzer = new StandardAnalyzer(Version.LUCENE_CURRENT);
  directory = FSDirectory.open(indexDir);
  
  //创建解析器
  QueryParser parser = new QueryParser(Version.LUCENE_CURRENT, "contents", analyzer);
  Query query = parser.parse(keyword);//获取查询对象
     
//  Query query1 = new TermQuery(new Term("contents", keyword));
//  Query query2 = new TermQuery(new Term("contents", keyword2));
//  BooleanQuery query = new BooleanQuery();
//  query.add(query1, Occur.SHOULD);
//  query.add(query2, Occur.SHOULD);
  
//  QueryParser parser = new MultiFieldQueryParser(Version.LUCENE_CURRENT, new String[]{"path", "contents"}, analyzer);
//  Query query = parser.parse(keyword);
     
  isearcher = new IndexSearcher(directory, true);  //创建索引搜索器
  TopDocs ts = isearcher.search(query, null, 100);  //执行搜索，获取查询结果集对象
     
  int totalHits = ts.totalHits;  //获取命中数
  System.out.println("命中数：" + totalHits);
     
  ScoreDoc[] hits = ts.scoreDocs;  //获取命中的文档信息对象
  for (int i = 0; i &lt; hits.length; i++) {
       Document hitDoc = isearcher.doc(hits[i].doc); //根据命中的文档的内部编号获取该文档 
       System.out.println(hitDoc.getField("contents").stringValue()); //输出该文档指定域的值
  }
 } catch (IOException e) {
  e.printStackTrace();  
 } catch (ParseException e) {
  e.printStackTrace();
 } finally {   
  if (isearcher != null) {   
   try {   
    isearcher.close(); //关闭搜索器  
   } catch (IOException e) {
    e.printStackTrace();
   }
  }
  if (directory != null) {   
   try {   
    directory.close(); //关闭索引存放目录 
   } catch (IOException e) {
    e.printStackTrace();
   }
  }
 }
}
</TEXTAREA> 
<P></P>
              <P>7. 删除索引<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexWriter提供deleteDocuments(Term term);&nbsp; 
                //会删除索引文件里含有指定Term的所有Document。<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexReader也提供了deleteDocuments(Term 
                term);</P>
              <P>8. 更新索引<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexWriter提供updateDocument(Term term, Document doc); 
                //实际上是先删除再创建索引。</P>
              <P>9. 常用查询器<BR>
                &nbsp; 1) TermQuery : 按Term（关键字）查询。构造方法：TermQuery(Term&nbsp;t) <BR>
              </P>
              
              <DIV class=dp-highlighter>
                <DIV class=bar></DIV>
                <OL class=dp-j>
                  <LI class=alt><SPAN><SPAN>Query&nbsp;query&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;TermQuery(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Term(</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>,&nbsp;keyword)); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>isearcher&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;IndexSearcher(FSDirectory.open(indexDir),&nbsp;</SPAN><SPAN 
class=keyword>true</SPAN><SPAN>); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>TopDocs&nbsp;ts&nbsp;=&nbsp;isearcher.search(query,&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=number>100</SPAN><SPAN>);&nbsp;&nbsp;&nbsp;</SPAN></SPAN></LI>
                </OL>
              </DIV><TEXTAREA class=java:nocontrols style="DISPLAY: none" rows=15 cols=50 name=code>      Query query = new TermQuery(new Term("contents", keyword));
      isearcher = new IndexSearcher(FSDirectory.open(indexDir), true);
      TopDocs ts = isearcher.search(query, null, 100); </TEXTAREA> 
<P></P>
              <P>&nbsp; 2) BooleanQuery: 布尔查询。组合多个查询器。<BR>
              </P>
              
              <DIV class=dp-highlighter>
                <DIV class=bar></DIV>
                <OL class=dp-j>
                  <LI class=alt><SPAN><SPAN>Query&nbsp;query1&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;TermQuery(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Term(</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>,&nbsp;keyword)); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>Query&nbsp;query2&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;TermQuery(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Term(</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>,&nbsp;keyword2)); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>BooleanQuery&nbsp;query&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;BooleanQuery(); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>query.add(query1,&nbsp;Occur.SHOULD); &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>query.add(query2,&nbsp;Occur.SHOULD); &nbsp;&nbsp;</SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>isearcher&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;IndexSearcher(directory,&nbsp;</SPAN><SPAN 
class=keyword>true</SPAN><SPAN>);&nbsp; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>&nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>TopDocs&nbsp;ts&nbsp;=&nbsp;isearcher.search(query,&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=number>100</SPAN><SPAN>);&nbsp;&nbsp;&nbsp;</SPAN></SPAN></LI>
                </OL>
              </DIV><TEXTAREA class=java:nocontrols style="DISPLAY: none" rows=15 cols=50 name=code>  Query query1 = new TermQuery(new Term("contents", keyword));
  Query query2 = new TermQuery(new Term("contents", keyword2));
  BooleanQuery query = new BooleanQuery();
  query.add(query1, Occur.SHOULD);
  query.add(query2, Occur.SHOULD);

  isearcher = new IndexSearcher(directory, true); 

  TopDocs ts = isearcher.search(query, null, 100); 
</TEXTAREA> 
<P></P>
              <P>&nbsp; 3) MultiFieldQueryParser: 多Field中查询。<BR>
              </P>
              
              <DIV class=dp-highlighter>
                <DIV class=bar></DIV>
                <OL class=dp-j>
                  <LI class=alt><SPAN><SPAN>QueryParser&nbsp;parser&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;MultiFieldQueryParser(Version.LUCENE_CURRENT,&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;String[]{</SPAN><SPAN 
class=string>"path"</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=string>"contents"</SPAN><SPAN>},&nbsp;analyzer); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>Query&nbsp;query&nbsp;=&nbsp;parser.parse(keyword); &nbsp;&nbsp;</SPAN>
                  <LI class=alt><SPAN>isearcher&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;IndexSearcher(FSDirectory.open(indexDir),&nbsp;</SPAN><SPAN 
class=keyword>true</SPAN><SPAN>); &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN>TopDocs&nbsp;ts&nbsp;=&nbsp;isearcher.search(query,&nbsp;</SPAN><SPAN 
class=keyword>null</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=number>100</SPAN><SPAN>);&nbsp;&nbsp;</SPAN></SPAN></LI>
                </OL>
              </DIV><TEXTAREA class=java:nocontrols style="DISPLAY: none" rows=15 cols=50 name=code>      QueryParser parser = new MultiFieldQueryParser(Version.LUCENE_CURRENT, new String[]{"path", "contents"}, analyzer);
      Query query = parser.parse(keyword);
      isearcher = new IndexSearcher(FSDirectory.open(indexDir), true);
      TopDocs ts = isearcher.search(query, null, 100);</TEXTAREA> 
<P></P>
              <P>10. 高亮器Highlighter：在网页中对搜索结果予以高亮显示。<BR>
                &nbsp;&nbsp; 1) 
                在classpath添加contrib/highlighter/lucene-highlighter-2.9.1.jar<BR>
                &nbsp;&nbsp; 2) 示例伪代码<BR>
              </P>
              
              <DIV class=dp-highlighter>
                <DIV class=bar></DIV>
                <OL class=dp-j>
                  <LI class=alt><SPAN><SPAN>SimpleHTMLFormatter&nbsp;shf&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;SimpleHTMLFormatter(</SPAN><SPAN 
class=string>"&lt;span&nbsp;style="</SPAN><SPAN>color:red</SPAN><SPAN 
class=string>"&nbsp;mce_style="</SPAN><SPAN>color:red</SPAN><SPAN 
class=string>"&gt;"</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=string>"&lt;/span&gt;"</SPAN><SPAN>);&nbsp;</SPAN><SPAN 
class=comment>//默认是&lt;b&gt;..&lt;/b&gt;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN class=comment>//&nbsp;构造高亮器:指定高亮的格式,指定查询计分器&nbsp;&nbsp;&nbsp; </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>Highlighter&nbsp;highlighter&nbsp;=&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;Highlighter(shf,&nbsp;</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;QueryScorer(query));&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</SPAN></SPAN>
                  <LI ><SPAN></SPAN><SPAN class=comment>//设置块划分器 </SPAN><SPAN>&nbsp;&nbsp;</SPAN></SPAN>
                  <LI class=alt><SPAN>highlighter.setTextFragmenter(</SPAN><SPAN 
class=keyword>new</SPAN><SPAN>&nbsp;SimpleFragmenter(Integer.MAX_VALUE));&nbsp;&nbsp; 
                    &nbsp;&nbsp;</SPAN></SPAN>
                  <LI 
><SPAN>String&nbsp;content&nbsp;=&nbsp;highlighter.getBestFragment(Analyzer,&nbsp;</SPAN><SPAN 
class=string>"fieldName"</SPAN><SPAN>,&nbsp;</SPAN><SPAN 
class=string>"fieldValue"</SPAN><SPAN>);&nbsp;&nbsp;</SPAN></SPAN></LI>
                </OL>
              </DIV><TEXTAREA class=java:nocontrols style="DISPLAY: none" rows=15 cols=50 name=code>       SimpleHTMLFormatter shf = new SimpleHTMLFormatter("&lt;span style="color:red" mce_style="color:red"&gt;", "&lt;/span&gt;"); //默认是&lt;b&gt;..&lt;/b&gt; 
       // 构造高亮器:指定高亮的格式,指定查询计分器   
       Highlighter highlighter = new Highlighter(shf, new QueryScorer(query));   
       //设置块划分器
       highlighter.setTextFragmenter(new SimpleFragmenter(Integer.MAX_VALUE));  
       String content = highlighter.getBestFragment(Analyzer, "fieldName", "fieldValue");</TEXTAREA> 

<P></P>
              <P>11. 优化<BR>
                &nbsp; 1) 使用IndexWriter须注意<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 修改索引后，需flush()或close()方能生效<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                非线程安全，任一时刻仅能有一个线程对其操作.<BR>
                &nbsp; 2) 使用IndexSearcher须注意<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                一旦打开，不会搜索到以后添加的索引<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 线程安全，多个线程仅需一个实例<BR>
                &nbsp; 3) 最佳实践<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                多个线程共享一个IndexSearcher, 只有当索引修改后才重新打开IndexSearcher<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                多个线程共享一个IndexWriter并严格同步<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 异步修改索引提高性能(JMS)<BR>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                为每个Document创建单独的索引目录<BR>
                &nbsp;&nbsp;&nbsp; <BR>
                12. 
                在emall项目中整合Lucene对产品的ID,名称和描述进行全文搜索。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </P>
              <P>13. 使用Compass简化Lucene操作。(未完待续)</P>
            </DIV>
          </DIV>
<P>&nbsp;</P>
<P>&nbsp;</P>
        </DIV>
      </DIV><!--EndFragment--></DIV>
  </DIV>
</DIV>
</BODY>
</HTML>